library IEEE;
use work.Proteinas_pck.all;
use ieee.std_logic_1164.all;

entity SystolicFordward is
	generic(
		NoCell		: 	natural  :=	8;
		dimH			: 	natural  :=	8
	);
	port(
		-- Input ports
		CLOCK_50		:	in	std_logic;
		reset			:	in std_logic;
		inDireccion	:	in std_logic;	--0 vertical, 1 horizontal
		inAminoH		:	in std_logic_vector(dimAmino-1 downto 0);
		inAminoV		:	in std_logic_vector(dimAmino-1 downto 0);
		
		-- prueba temporal
		--outH1			:	out	std_logic_vector(7 downto 0);
		--outH2			:	out	std_logic_vector(7 downto 0);
		--outH3			:	out	std_logic_vector(7 downto 0);
		--outH4			:	out	std_logic_vector(7 downto 0);
		--outH5			:	out	std_logic_vector(7 downto 0);
		flag			:	out	std_logic;

		-- Output ports
		outDireccionVector	:	out std_logic_vector(2*NoCell-1 downto 0)
	);
end SystolicFordward;

	--(0 => Ne, others => '0')
	--(others => '0')	

architecture rtl of SystolicFordward is

	Type TipoAminoArray	is	Array (NoCell downto 0) of std_logic_vector(dimAmino-1 downto 0);
	Type TipoHArray	is	Array (NoCell+1 downto 0) of std_logic_vector(dimH-1 downto 0);
	Type TipoDireccionArray	is	Array (NoCell downto 1) of std_logic_vector(1 downto 0);
	
	
	signal	arrayInAminoH, arrayInAminoV											:	TipoAminoArray;
	signal	arrayDelayH0,	arrayDelayH1,	arrayDelayH2,	arrayDelayH3	:	TipoHArray;
	signal	arrayHU,	arrayHL															:	TipoHArray;
	signal	arrayDireccion																:	TipoDireccionArray;
	signal	DireccionVector	:	std_logic_vector(2*NoCell-1 downto 0);
	signal	andAux		:	std_logic_vector(NoCell downto 1);
	signal	sensorAnd	:	std_logic;
	signal	regulador	:	std_logic_vector(NoCell downto 1) := (others => '1');
	
	
	
	Type TipoADN	is	Array (NoCell+1 downto 0) of std_logic_vector(dimAmino-1 downto 0);
	Type TipoH		is	Array (NoCell+1 downto 0) of std_logic_vector(dimH-1 downto 0);
	Type TipoArrow	is	Array (NoCell+1 downto 0) of std_logic_vector(1 downto 0);
	
	signal	sADNa,sADNb, rADNa,rADNb	:	TipoADN;
	signal	sH, rH1, rH2					:	TipoH;
	signal	sArrow, rArrow					:	TipoArrow;
	
	
	component AlineadorProteinas is
		generic(
			dimH		: 	natural  :=	lengthH
		);
		port
		(
			-- Input ports
			CLOCK_50		:	in	std_logic;
			reset			:	in std_logic;
			inAminoH		:	in std_logic_vector(dimAmino-1 downto 0);
			inAminoV		:	in std_logic_vector(dimAmino-1 downto 0);
			inHdiag		:	in std_logic_vector(dimH-1 downto 0);
			inHup			:	in std_logic_vector(dimH-1 downto 0);
			inHleft		:	in std_logic_vector(dimH-1 downto 0);

			-- Output ports
			outH				:	out std_logic_vector(dimH-1 downto 0);
			outDireccion	:	out std_logic_vector(1 downto 0)
		);
	end component;
	
	component PEadn is
		generic(
			dimH		: 	natural  :=	lengthH
		);
		port
		(
			-- Input ports
			CLOCK_50		:	in	std_logic;
			reset			:	in std_logic;
			iADNa			:	in std_logic_vector(dimAmino-1 downto 0);
			iADNb			:	in std_logic_vector(dimAmino-1 downto 0);
			iHd			:	in std_logic_vector(dimH-1 downto 0);
			iHu			:	in std_logic_vector(dimH-1 downto 0);
			iHl			:	in std_logic_vector(dimH-1 downto 0);

			-- Output ports
			oADNa			:	out std_logic_vector(dimAmino-1 downto 0);
			oADNb			:	out std_logic_vector(dimAmino-1 downto 0);
			oH				:	out std_logic_vector(dimH-1 downto 0);
			oArrow		:	out std_logic_vector(1 downto 0)
		);
	end component;
	
	component pipelineKBand is
		generic(
			dimH		: 	natural  :=	lengthH
		);
		port
		(
			-- Input ports
			CLOCK_50		:	in	std_logic;
			reset			:	in std_logic;
			iADNa			:	in std_logic_vector(dimAmino-1 downto 0);
			iADNb			:	in std_logic_vector(dimAmino-1 downto 0);
			iH				:	in std_logic_vector(dimH-1 downto 0);
			iArrow		:	in std_logic_vector(1 downto 0);
			-- Output ports
			oADNa			:	out std_logic_vector(dimAmino-1 downto 0);
			oADNb			:	out std_logic_vector(dimAmino-1 downto 0);
			oH1			:	out std_logic_vector(dimH-1 downto 0);
			oH2			:	out std_logic_vector(dimH-1 downto 0);
			oArrow		:	out std_logic_vector(1 downto 0)
		);
	end component;
	
begin
	
	--crea las celdas de procesamiento
	processor_cell: 
	for i in 1 to NoCell generate
		PE: PEadn
		generic map(
			dimH		=>	lengthH
		)
		port map(
			-- Input ports
			CLOCK_50		=>	CLOCK_50,
			reset			=>	reset,
			iADNa			=>	rADNa(i-1),
			iADNb			=>	rADNb(i),--arrayInAminoV(NoCell+1 - i),
			iHd			=>	rH2(i),
			iHu			=>	arrayHU(i),
			iHl			=>	arrayHL(i),

			-- Output ports
			oADNa			=>	sADNa(i),
			oADNb			=>	sADNb(i),
			oH				=>	sH(i), --igual a antes en H1, h0
			oArrow		=>	sArrow(i)
		);
	end generate;
	
	--crea los registros de pipeline
	register_cell: 
	for i in 0 to NoCell generate
		rPIPE	:	pipelineKBand
		generic map(
			dimH		=>	lengthH
		)
		port map(
			-- Input ports
			CLOCK_50		=>	CLOCK_50,
			reset			=>	reset,
			iADNa			=>	sADNa(i),
			iADNb			=>	sADNb(i+1),
			iH				=>	sH(i),
			iArrow		=>	sArrow(i),
			-- Output ports
			oADNa			=>	rADNa(i),
			oADNb			=>	rADNb(i),
			oH1			=>	rH1(i),
			oH2			=>	rH2(i),
			oArrow		=>	rArrow(i)
		);
	end generate;
	
	--REGISTROS
	--carga los registros de desplazamiento
	sADNb(NoCell+1)	<=	inAminoH;
	sADNa(0)				<=	inAminoV;
	
	
	
	--crea los multiplexores
	--son los registros que se conectan en U y L en los bordes
	rH1(NoCell+1)	<=	(dimH-1-2 => '0', others => '1'); --(others => '1');
	sH(0)			<=	(dimH-1-2 => '0', others => '1');
	
	mux:
	for i in 1 to NoCell generate
		mux_U: arrayHU(i) <=	rH1(i) when inDireccion = '1' else rH1(i+1); --si el ultimo movimiento fue vertical (0)										
		mux_L: arrayHL(i) <=	rH1(i) when inDireccion = '0' else rH1(i-1); --si el ultimo movimiento fue horizontal(1)											
	end generate;

	
	--AND del segundo bit mas significativo
	and_sensor:
	for i in 1 to NoCell generate
		andAux(i)	<=	arrayDelayH1(i)(DimH-2) and arrayDelayH2(i)(DimH-2) and arrayDelayH3(i)(DimH-2);
	end generate;
	sensorAnd	<=	'1' when andAux = (andAux'range => '1') else '0';
	flag	<=	inDireccion;
	
	--pasa el array a std_logic_vector
	array2stdLogicVector: 
	for i in 0 to NoCell-1 generate
		DireccionVector(2*i+1 downto 2*i)	<=	rArrow(i+1);		
	end generate;
	outDireccionVector	<=	DireccionVector;
	
	
end rtl;

