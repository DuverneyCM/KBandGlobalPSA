library IEEE;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity KbandControl is
	port(
		-- clk and reset interface
		clk, reset															:	in		std_logic;
		-- Sink control
		oSinkAdquirir
		oSinkRead
		iSinkFIFOempty1
		iSinkFIFOempty2
		--interLogic Ports
		iADNen																:	in	std_logic;
		oFIFOfull															:	out	std_logic;
		iArrows																:	in	std_logic_vector(2*NoCell downto 1);
		
		iFlag, iADNfinish													:	in	std_logic
	);
end KbandControl;

architecture rtl of KbandControl  is
	constant	bitsIN	: 	natural  :=	2*NoCell;	--MULTIPLOS DE 32
component FifoKBandOUT IS
	GENERIC(
		bitsIN		: 	natural  :=	128;	--MULTIPLOS DE 32
		bitsOUT		: 	natural  :=	32;	--32
		widthu		: 	natural  :=	8
	);
	PORT(
		aclr		: IN STD_LOGIC  := '0';
		data		: IN STD_LOGIC_VECTOR (bitsIN-1 DOWNTO 0);
		rdclk		: IN STD_LOGIC ;
		rdreq		: IN STD_LOGIC ;
		wrclk		: IN STD_LOGIC ;
		wrreq		: IN STD_LOGIC ;
		q			: OUT STD_LOGIC_VECTOR (bitsOUT-1 DOWNTO 0);
		rdempty	: OUT STD_LOGIC ;
		wrfull	: OUT STD_LOGIC 
	);
END component;

signal	sFifoDataIn, shReg	:	std_logic_vector(bitsIN downto 1);
signal	sFifoCount	:	std_logic_vector(6 downto 0);
signal	sFifoRead, sFifoWrite, sFifoEmpty, sFifoFull	:	std_logic;
signal	sLoadShReg, shr	:	std_logic;
signal	cnt	:	std_logic_vector(3 downto 0);

	type state_type is (s0, s1, s2, s3);
	signal state   : state_type;
	
begin
	sFifoDataIn		<=	iArrows;
	sFIfoRead		<=	din_Ready and not sFifoEmpty;
	sFifoWrite		<=	iADNen and not sFifoFull;
	oFIFOfull		<=	sFifoFull;
	
		--Retardos de sincronizacion
	process(reset, clk) is 
	begin 
		if(reset = '1') then
			dout_Valid	<= '0';
		elsif(rising_edge(clk)) then
			dout_Valid	<=	sFifoRead;
		end if;
	end process;
	
	--FIFO buffer
	uFIFOout	:	FifoKBandOUT
	generic map( bitsIN, bitsOUT, widthu )
	port map(
		aclr			=>	reset,
		data		=>	sFifoDataIn,
		rdclk		=>	clk,
		rdreq		=>	sFifoRead,
		wrclk		=>	clk,
		wrreq		=>	sFifoWrite,
		q				=>	dout_Data,
		rdempty	=>	sFifoEmpty,
		wrfull		=>	sFifoFull
	);
end rtl;